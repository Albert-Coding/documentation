---
id: testing
title: Application development - Testing
sidebar_label: Testing
description: The Testing section of the Temporal Application development guide covers the many ways to test the state of your Temporal Application; that is, ways to view which Workflow Executions are tracked by the Platform and the state of any given Workflow Execution, either currently or at points of an execution.
toc_max_heading_level: 4
---

<!-- THIS FILE IS GENERATED. DO NOT EDIT THIS FILE DIRECTLY -->

The testing section of the Temporal Application development guide describes the frameworks that facilitate Workflow and integration testing.

In the context of Temporal, you can create these types of automated tests:

- **End-to-end**: Running a Temporal Server and Worker with all its Workflows and Activities; starting and interacting with Workflows from a Client.
  - Running Activities with mocked Context and other SDK imports (and usually network requests).
  - Running Workers with mock Activities, and using a Client to start Workflows.
  - Running Workflows with mocked SDK imports.
- **Integration**: Anything between end-to-end and unit testing, including:
- **Unit**: Running a piece of Workflow or Activity code (a function or method) and mocking any code it calls.

We generally recommend writing the majority of your tests as integration tests.

For both end-to-end tests and integration tests with a Worker, we recommend using the Test Server, as it supports [skipping time](#skip-time).

## Test Activities

Activities can be tested with a mock Activity environment, which provides a way to mock Activity context, listen to heartbeats, and cancel the Activity. This allows you to test the Activity in isolation by calling it directly, without needing to create a Worker to run the Activity.

### Run an Activity

If an Activity references its context, you need to mock that context when testing in isolation.

### Listen to Heartbeats

When an Activity sends Heartbeats, you want to be able to see them in your test code in order to assert they’re correct.

### Cancel an Activity

If an Activity is supposed to react to Cancellation, you can test whether it reacts correctly by canceling it.

## Test Workflows

### Mock Activities

When unit testing Workflows, you can mock the Activity invocation. When integration testing Workflows with a Worker, you can mock Activities by providing mock Activity implementations to the Worker.

### Skip Time

Running Workflow code in integration and end-to-end tests often requires the ability to skip time: you need your tests to run in seconds or minutes, but a Workflow might sleep for a day, or have Activity failures with long retry intervals. While testing, you don’t need to test whether the sleep function works—you can trust Temporal functionality to correctly execute. Instead, you want to test the logic that happens after sleeping. You can skip forward a day during testing to see what happens in a timely manner.

:::note

Skipping time is not relevant to unit testing Workflow code, since in that case you’re mocking functions that take time like sleep and Activity calls.

:::

The Test Server included in most SDKs is an in-memory implementation of Temporal Server that supports skipping time. Time is a global property of an instance of the Test Server: if you skip time (either automatically or manually), it applies to all currently running tests. If you need different time behaviors for different tests, they need to be run in series or with separate Test Server instances. For example, you could run all tests with automatic time skipping in parallel, and then all tests with manual time skipping in series, and then all tests without time skipping in parallel.

#### Setting up

Learn to set up the Time Skip server in the SDK of your choice.

<Tabs
defaultValue="go"
groupId="site-lang"
values={[{label: 'Go', value: 'go'},{label: 'Java', value: 'java'},{label: 'PHP', value: 'php'},{label: 'Python', value: 'python'},{label: 'TypeScript', value: 'typescript'},]}>

<TabItem value="go">

Content is currently unavailable.

</TabItem>
<TabItem value="java">

Content is currently unavailable.

</TabItem>
<TabItem value="php">

Content is currently unavailable.

</TabItem>
<TabItem value="python">

Content is currently unavailable.

</TabItem>
<TabItem value="typescript">

```bash
npm install @temporalio/testing
```

The `@temporalio/testing` package downloads the Test Server and exports [`TestWorkflowEnvironment`](https://typescript.temporal.io/api/classes/testing.TestWorkflowEnvironment), which you use to connect the Client and Worker to the Test Server and interact with the Test Server.

[`TestWorkflowEnvironment.create`](https://typescript.temporal.io/api/classes/testing.TestWorkflowEnvironment#create) starts the Test Server. A typical test suite should set up a single instance of the test environment to be reused in all tests (for example, in a [Jest](https://jestjs.io/) `beforeAll` hook or a [Mocha](https://mochajs.org/) `before()` hook).

```typescript
import {TestWorkflowEnvironment} from "@temporalio/testing";

let testEnv: TestWorkflowEnvironment;

// beforeAll and afterAll are injected by Jest
beforeAll(async () => {
  testEnv = await TestWorkflowEnvironment.create();
});

afterAll(async () => {
  await testEnv?.teardown();
});
```

`TestWorkflowEnvironment` has a [`workflowClient`](https://typescript.temporal.io/api/classes/testing.TestWorkflowEnvironment#workflowclient) and [`nativeConnection`](https://typescript.temporal.io/api/classes/testing.TestWorkflowEnvironment#nativeconnection) for creating Workers:

```typescript
import { Worker } from '@temporalio/worker';
import { v4 as uuid4 } from 'uuid';
import { workflowFoo } from './workflows';

test('workflowFoo', async () => {
  const worker = await Worker.create({
    connection: testEnv.nativeConnection,
    taskQueue: 'test',
    ...
  });
  const result = await worker.runUntil(
    testEnv.workflowClient.execute(workflowFoo, {
      workflowId: uuid4(),
      taskQueue: 'test',
    })
  );
  expect(result).toEqual('foo');
});
```

This test uses the test connection to create a Worker, runs the Worker until the Workflow is complete, and then makes an assertion about the Workflow’s result. The Workflow is executed using `testEnv.workflowClient`, which is connected to the Test Server.

</TabItem>
</Tabs>

#### Automatic method

Learn to Time Skip automatically in the SDK of your choice.

<Tabs
defaultValue="go"
groupId="site-lang"
values={[{label: 'Go', value: 'go'},{label: 'Java', value: 'java'},{label: 'PHP', value: 'php'},{label: 'Python', value: 'python'},{label: 'TypeScript', value: 'typescript'},]}>

<TabItem value="go">

Content is currently unavailable.

</TabItem>
<TabItem value="java">

Content is currently unavailable.

</TabItem>
<TabItem value="php">

Content is currently unavailable.

</TabItem>
<TabItem value="python">

Content is currently unavailable.

</TabItem>
<TabItem value="typescript">

The Test Server starts in "normal" time. When you use `TestWorkflowEnvironment.workflowClient.execute()` or `.result()`, the Test Server is switched to "skipped" time mode until the Workflow completes. In "skipped" mode, timers (`sleep()`s and `condition()` timeouts) are fast-forwarded except when Activities are running.

`workflows.ts`

```ts
import {sleep} from "@temporalio/workflow";

export async function sleeperWorkflow() {
  await sleep("1 day");
}
```

`test.ts`

```ts
import {sleeperWorkflow} from "./workflows";

test("sleep completes almost immediately", async () => {
  const worker = await Worker.create({
    connection: testEnv.nativeConnection,
    taskQueue: "test",
    workflowsPath: require.resolve("./workflows"),
  });
  // Does not wait an entire day
  await worker.runUntil(
    testEnv.workflowClient.execute(sleeperWorkflow, {
      workflowId: uuid(),
      taskQueue: "test",
    })
  );
});
```

</TabItem>
</Tabs>

#### Manual method

Learn to Time Skip manually in the SDK of your choice.

<Tabs
defaultValue="go"
groupId="site-lang"
values={[{label: 'Go', value: 'go'},{label: 'Java', value: 'java'},{label: 'PHP', value: 'php'},{label: 'Python', value: 'python'},{label: 'TypeScript', value: 'typescript'},]}>

<TabItem value="go">

Content is currently unavailable.

</TabItem>
<TabItem value="java">

Content is currently unavailable.

</TabItem>
<TabItem value="php">

Content is currently unavailable.

</TabItem>
<TabItem value="python">

Content is currently unavailable.

</TabItem>
<TabItem value="typescript">

You can also call `testEnv.sleep()` from your test code to advance the Test Server's time.
This is useful for testing intermediate state, or for testing indefinitely long-running Workflows.
However, to use `testEnv.sleep()`, you need to avoid automatic time skipping by starting the Workflow with `.start()` instead of `.execute()` (and not calling `.result()`).

`workflow.ts`

```ts
import {sleep} from "@temporalio/workflow";
import {defineQuery, setHandler} from "@temporalio/workflow";

export const daysQuery = defineQuery("days");

export async function sleeperWorkflow() {
  let numDays = 0;

  setHandler(daysQuery, () => numDays);

  for (let i = 0; i < 100; i++) {
    await sleep("1 day");
    numDays++;
  }
}
```

`test.ts`

```ts
test("sleeperWorkflow counts days correctly", async () => {
  // `start()` starts the test server in "normal" mode, not skipped time mode.
  // If you don't advance time using `testEnv.sleep()`, then `sleeperWorkflow()`
  // will run for days.
  handle = await testEnv.workflowClient.start(sleeperWorkflow, {
    workflowId: uuid4(),
    taskQueue,
  });

  let numDays = await handle.query(daysQuery);
  assert.equal(numDays, 0);

  // Advance the test server's time by 25 hours
  await testEnv.sleep("25 hours");
  numDays = await handle.query(daysQuery);
  assert.equal(numDays, 1);

  await testEnv.sleep("25 hours");
  numDays = await handle.query(daysQuery);
  assert.equal(numDays, 2);
});
```

</TabItem>
</Tabs>

#### Skip Activities

Learn to Time Skip Activities in the SDK of your choice.

<Tabs
defaultValue="go"
groupId="site-lang"
values={[{label: 'Go', value: 'go'},{label: 'Java', value: 'java'},{label: 'PHP', value: 'php'},{label: 'Python', value: 'python'},{label: 'TypeScript', value: 'typescript'},]}>

<TabItem value="go">

Content is currently unavailable.

</TabItem>
<TabItem value="java">

Content is currently unavailable.

</TabItem>
<TabItem value="php">

Content is currently unavailable.

</TabItem>
<TabItem value="python">

Content is currently unavailable.

</TabItem>
<TabItem value="typescript">

Call
[`TestWorkflowEnvironment.sleep`](https://typescript.temporal.io/api/classes/testing.testworkflowenvironment/#sleep)
from the mock Activity.

In the below test, `processOrderWorkflow` sends a notification to the user after 1 day. The `processOrder` mocked Activity calls `testEnv.sleep(‘2 days’)`, during which the Workflow will send the email (by calling the `sendNotificationEmail` Activity). Then once the Workflow completes, we assert that `sendNotificationEmail` was called.

<details>
<summary>
Workflow implementation
</summary>

<!--SNIPSTART typescript-timer-reminder-workflow-->
<!--SNIPEND-->

</details>

<!--SNIPSTART typescript-timer-reminder-test-->
<!--SNIPEND-->

</TabItem>
</Tabs>

### Workflow context

In order for a function or method to be run in the Workflow context (where it’s possible to get the current Workflow info, or running inside the sandbox/isolate in the case of TS and Python), it needs to be run by the Worker as if it were a Workflow.

:::note

This section is applicable in Python and TypeScript. In Python we only allow testing of Workflows and not generic Workflow-related code.

:::

<Tabs
defaultValue="go"
groupId="site-lang"
values={[{label: 'Go', value: 'go'},{label: 'Java', value: 'java'},{label: 'PHP', value: 'php'},{label: 'Python', value: 'python'},{label: 'TypeScript', value: 'typescript'},]}>

<TabItem value="go">

Content is currently unavailable.

</TabItem>
<TabItem value="java">

Content is currently unavailable.

</TabItem>
<TabItem value="php">

Content is currently unavailable.

</TabItem>
<TabItem value="python">

Content is currently unavailable.

</TabItem>
<TabItem value="typescript">

To test a function in your Workflow code that isn’t a Workflow, put the file it’s exported from in [WorkerOptions.workflowsPath](https://typescript.temporal.io/api/interfaces/worker.WorkerOptions#workflowspath). Then execute it as if it were a Workflow:

`workflows/file-with-workflow-function-to-test.ts`

```ts
import {sleep} from "@temporalio/workflow";

export async function functionToTest(): Promise<number> {
  await sleep("1 day");
  return 42;
}
```

`test.ts`

```ts
const worker = await Worker.create({
  connection: testEnv.nativeConnection,
  workflowsPath: require.resolve(
    "./workflows/file-with-workflow-function-to-test"
  ),
});

const result = await worker.runUntil(
  testEnv.workflowClient.execute(functionToTest, workflowOptions)
);

assert.equal(result, 42);
```

If the `functionToTest` starts a Child Workflow, that Workflow must be exported from the same file (so that the Worker knows about it):

```ts
import {sleep} from "@temporalio/workflow";
import {someWorkflowToRunAsChild} from "./some-workflow";

export {someWorkflowToRunAsChild};

export async function functionToTest(): Promise<number> {
  const result = await wf.executeChild(someWorkflowToRunAsChild);
  return result + 42;
}
```

</TabItem>
</Tabs>

### Assert in Workflow

The `assert` statement is a convenient way to insert debugging assertions into the Workflow context.

The `assert` method is available in Python and TypeScript.

<Tabs
defaultValue="go"
groupId="site-lang"
values={[{label: 'Go', value: 'go'},{label: 'Java', value: 'java'},{label: 'PHP', value: 'php'},{label: 'Python', value: 'python'},{label: 'TypeScript', value: 'typescript'},]}>

<TabItem value="go">

Content is currently unavailable.

</TabItem>
<TabItem value="java">

Content is currently unavailable.

</TabItem>
<TabItem value="php">

Content is currently unavailable.

</TabItem>
<TabItem value="python">

For information about assert statements in Python, see [`assert`](https://docs.python.org/3/reference/simple_stmts.html#the-assert-statement) in the Python Language Reference.

</TabItem>
<TabItem value="typescript">

The Node.js [`assert`](https://nodejs.org/api/assert.html) module is included in Workflow bundles.

By default, failed `assert` statements throw `AssertionError`s which cause [Workflow Tasks](/tasks#workflow-task) to fail and be indefinitely retried.

To prevent this, use [`workflowInterceptorModules`](https://typescript.temporal.io/api/namespaces/testing/#workflowinterceptormodules) from `@temporalio/testing`. These interceptors catch `AssertionError`s and turn them into `ApplicationFailure`s that fail the entire Workflow Execution (not just the Workflow Task).

`workflows/file-with-workflow-function-to-test.ts`

```ts
import assert from "assert";

export async function functionToTest() {
  assert.ok(false);
}
```

`test.ts`

```ts
import {
  TestWorkflowEnvironment,
  workflowInterceptorModules,
} from "@temporalio/testing";

const worker = await Worker.create({
  connection: testEnv.nativeConnection,
  interceptors: {
    workflowModules: workflowInterceptorModules,
  },
  workflowsPath: require.resolve(
    "./workflows/file-with-workflow-function-to-test"
  ),
});

await worker.runUntil(
  testEnv.workflowClient.execute(functionToTest, workflowOptions) // throws WorkflowFailedError
);
```

</TabItem>
</Tabs>

## Test Frameworks

Some SDKs have support for or examples with popular test frameworks/runners/libraries.

<Tabs
defaultValue="go"
groupId="site-lang"
values={[{label: 'Go', value: 'go'},{label: 'Java', value: 'java'},{label: 'PHP', value: 'php'},{label: 'Python', value: 'python'},{label: 'TypeScript', value: 'typescript'},]}>

<TabItem value="go">

Content is currently unavailable.

</TabItem>
<TabItem value="java">

Content is currently unavailable.

</TabItem>
<TabItem value="php">

Content is currently unavailable.

</TabItem>
<TabItem value="python">

Content is currently unavailable.

</TabItem>
<TabItem value="typescript">

TypeScript has sample tests with [Jest](https://jestjs.io/) and [Mocha](https://mochajs.org/).

**Jest**

- Minimum Jest version: `27.0.0`
  <<<<<<< HEAD
- # [Sample test file](https://github.com/temporalio/samples-typescript/blob/main/activities-examples/src/workflows.test.ts)
- [Sample test file](https://github.com/temporalio/samples-typescript/blob/main/activities-examples/src/workflows.t
  est.ts)
  > > > > > > > cc8379314f58230c1c25a621f5549015901dd17f
- [`jest.config.js`](https://github.com/temporalio/samples-typescript/blob/main/activities-examples/jest.config.js) (Must use [`testEnvironment: 'node'`](https://jestjs.io/docs/configuration#testenvironment-string). `testEnvironment: 'jsdom'` is not supported.)

**Mocha**

- [Sample test file](https://github.com/temporalio/samples-typescript/blob/main/activities-examples/src/mocha/workflows.test.ts)
- Test coverage library: [`@temporalio/nyc-test-coverage`](https://github.com/temporalio/sdk-typescript/tree/main/packages/nyc-test-coverage)

</TabItem>
</Tabs>

## Replay

Replay recreates the exact state of a Workflow Execution.
You can replay a Workflow from the beginning of its history when resumed.

Replay allows code to resume only if it is compatible from a deterministic point of view.

To retrieve the Workflow History, use any of the following options and then pass the object to your SDK of choice.

<Tabs
defaultValue="go"
groupId="site-lang"
values={[{label: 'Go', value: 'go'},{label: 'Java', value: 'java'},{label: 'PHP', value: 'php'},{label: 'Python', value: 'python'},{label: 'TypeScript', value: 'typescript'},]}>

<TabItem value="go">

Use the [worker.WorflowReplayer](https://pkg.go.dev/go.temporal.io/sdk/worker#WorkflowReplayer) to replay an existing Workflow Execution from its Event History to replicate errors.

For example, the following code retrieves the Event History of a Workflow:

```go
import (
	"context"

	"go.temporal.io/api/enums/v1"
	"go.temporal.io/api/history/v1"
	"go.temporal.io/sdk/client"
)

func GetWorkflowHistory(ctx context.Context, client client.Client, id, runID string) (*history.History, error) {
	var hist history.History
	iter := client.GetWorkflowHistory(ctx, id, runID, false, enums.HISTORY_EVENT_FILTER_TYPE_ALL_EVENT)
	for iter.HasNext() {
		event, err := iter.Next()
		if err != nil {
			return nil, err
		}
		hist.Events = append(hist.Events, event)
	}
	return &hist, nil
}
```

This history can then be used to _replay_.
For example, the following code creates a `WorkflowReplayer` and register the `YourWorkflow` Workflow function.
Then it calls the `ReplayWorkflowHistory` to _replay_ the Event History and return an error code.

```go
import (
	"context"

	"go.temporal.io/sdk/client"
	"go.temporal.io/sdk/worker"
)

func ReplayWorkflow(ctx context.Context, client client.Client, id, runID string) error {
	hist, err := GetWorkflowHistory(ctx, client, id, runID)
	if err != nil {
		return err
	}
	replayer := worker.NewWorkflowReplayer()
	replayer.RegisterWorkflow(YourWorkflow)
	return replayer.ReplayWorkflowHistory(nil, hist)
}
```

The code above will cause the Worker to re-execute the Workflow's Workflow Function using the original Event History.
If a noticeably different code path was followed or some code caused a deadlock, it will be returned in the error code.
Replaying a Workflow Execution locally is a good way to see exactly what code path was taken for given input and events.

</TabItem>
<TabItem value="java">

Content is currently unavailable.

</TabItem>
<TabItem value="php">

Content is currently unavailable.

</TabItem>
<TabItem value="python">

To replay a Workflow Execution, use the [`replay_workflow()`](https://python.temporal.io/temporalio.worker.replayer#replay_workflow) method and pass a Workflow History as an argument.

In the following example, `history_json_str` references the Workflow History as a JSON string.

```python
async def run_replayer(history_json_str: str):
    replayer = Replayer(workflows=[YourWorkflow])
    await replayer.replay_workflow(history_json_str)
```

If the Workflow History is non-deterministic, `run_replayer()` raises an error.

:::note

If the Workflow History is exported by [Temporal Web UI](/web-ui) or through [tctl](/tctl), you can pass the JSON file history object as a JSON string or as a Python dictionary through the `json.load()` function, which takes a file object and returns the JSON object.

:::

</TabItem>
<TabItem value="typescript">

Retrieve Event History with [`WorkflowService.getWorkflowExecutionHistory`](https://typescript.temporal.io/api/classes/proto.temporal.api.workflowservice.v1.workflowservice-1/#getworkflowexecutionhistory).

<!--SNIPSTART typescript-history-get-workflowhistory-->
<!--SNIPEND-->

Then call [`Worker.runReplayHistory`](https://typescript.temporal.io/api/classes/worker.worker/#runreplayhistory).

<!--SNIPSTART typescript-history-replay-->
<!--SNIPEND-->

`runReplayHistory` will throw a [`DeterminismViolationError`](https://typescript.temporal.io/api/classes/workflow.determinismviolationerror/) if the Workflow code isn’t compatible with the History.

</TabItem>
</Tabs>
